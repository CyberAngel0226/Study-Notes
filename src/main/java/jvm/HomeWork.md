### Java 内存区域：
- 堆：是线程共享的，JVM 中用来存放所有对象的内存空间，其分为新生代（包含 eden 区和 survivor 区）和老年代，JDK 1.7版本以前还有存放方法区中 class、常量池、编译后代码缓存的永久代；在 JDK1.8 之后被元空间所代替，从堆中移除了这部分除了常量池之外的内容放入了内存。
- 虚拟机栈：线程私有的，是 JVM 中方法执行的数据结构，其中以栈帧的形式存储调用方法的结构。每个栈帧代表一个方法的调用，其中包含局部变量、操作数、方法出口等内容。当方法栈帧过多超出栈容量会发生 StackOverFlow 异常。执行线程过多，创建栈超过栈数量上限时会发生 OutOfMemory。
- 本地方法栈：线程私有的，用于存储本地方法，例如 Java 底层以 C++ 实现的 native 方法的调用。
- 方法区：线程共享的，是 Java 代码编译后的存放区域，其中包含每个类的数据结构（成员变量、构造方法、普通方法等）、常量池、编译后的代码缓存，以字节码的形式存储。在 JDK1.7 版本之前存在堆内存中，被称为永久代；JDK1.8 之后存在本地内存中，被称为元空间，元空间中不存储常量池，会将常量池移入堆中。
- 运行时常量池：一个 class 对象有一个运行时常量池，用于存储 int、float、long 等变量、双引号标记的字符串以及 Class、Field、Method 等符号引用。其中字符串常量池为特殊的运行时常量池，其仅存储双引号标记的字符串常量，以 HashTable 的格式存储。
- 直接内存：非 JVM 的一部分，在产生 IO 时会使用，只有在用户输入输出流存入会显著提高性能；但一般情况下申请直接内存会使性能变慢。

### Java 对象的生命周期：
创建 -> 新生代 （-> 老年代） -> 销毁。
1. 创建过程：
    - 发起 new 指令，判断常量池中是否能定位到需要创建的类。
      - 如果能够定位到，则判断是否已加载。
      - 如果类已加载，则开始分配内存空间。
      - 如果无法定位到或类未加载，则执行类加载成功后，分配内存空间。
    - 分配内存空间后进行对象头中必要信息的设置。
    - 执行初始化 init。
2. 对象的内存分配：
   - 新对象申请内存：首先检查新生代：
     - eden 区是否能放下，能放下则放入新生代
     - eden 区放不下，执行 young GC ，并判断 young GC 后是否能放下
     - 能够放下就放入eden 区，否则考虑是否进入老年代
   - 新生代 young GC 后放不下，检查老年代：
     - 老年代是否能放下，能则放入老年代
     - 放不下执行 Full GC，并判断老年代是否能放下
     - 能放下就放入老年代，否则抛出 OutOfMemory 异常
3. 对象销毁过程：  
    - 第一次标记，在要执行 young GC 或 Full GC 时，如果一个对象未被引用变为垃圾对象，需要回收，则会先进行第一次标记。
    - 第二次标记，筛选第一次标记的对象是否有必要执行 Finalize 方法，有必要则执行，如果未执行或执行后对象仍无有效引用，则回收销毁。
4. 对象的两种访问形式：
    - 句柄：程序执行时，栈会通过 reference 寻找堆中句柄池对象的指针，然后通过指针访问对象实例数据。
    - 直接指针访问：reference 直接存储对象指针，直接通过该指针访问对象实例数据。
5. 为什么需要内存担保？  
    因为新生代内存空间较小，假设大量对象在 young GC 后仍存活，会导致新生代无法接纳新的较大对象，这时就需要老年代进行内存担保，存储新生代当前对象，前提是老年代有充足的空间存储这些担保过来的对象。

### 垃圾回收算法有哪些，垃圾收集器有哪些，其特点是？
1. 垃圾回收算法：
   - 标记-清除算法：其会先标记堆内存中需要回收的对象，然后执行清除，该算法会导致出现碎片化的内存。
   - 复制算法：先将堆内存中不需要清除的对象复制到一块新的内存中，在将原内存中对象删除，空间换时间，效率高但费空间。新生代的 survivor 区就是这么设计的。
   - 标记-整理算法：先标记堆内存中需要回收的对象，然后执行清除，清除后整理剩下的对象，避免碎片化的内存。相较于前两种算法效率较低。
2. 垃圾回收器有八种，分别是 serial、parallelScavenge、parNew、serialOld、parallelOld、CMS、G1、ZGC。
    - serial、serialOld：
      - serial 是新生代使用的单线程串型垃圾收集器，其采用复制算法进行 GC。
      - serialOld 是老年代使用的单线程串型垃圾收集器，其采用标记-整理算法进行 GC。
      - 特点：在安全点处会挂起用户线程（STW）进行垃圾回收。
    - parallelScavenge、parallelOld：
      - parallelScavenge 新生代使用的并行垃圾收集器，采用复制算法进行 GC；老年代使用的话则是串型。
      - parallelOld：老年代使用的并行垃圾收集器，采用标记-整理算法算法进行 GC。
      - 特点；吞吐量优先，考虑 CPU 资源少时用。
    - parNew：
      - 新生代并行采用复制算法、老年代串型采用标记-整理算法的垃圾收集器。
      - 特点：响应时间优先，是 serial 的多线程版本，不适用于单核处理器。
    - CMS：
      - 老年代使用的并行的垃圾收集器，采用标记-清除算法。
      - 特点：响应时间优先，将回收过程拆分为标记->并行标记->重新标记->并发清理。以减少 STW 时间。其中仅标记和重新标记需要 STW，且重新标记仅是对并行标记的结果进行处理，大大提高了效率。
    - G1：
      - 新老年代都可以使用的并行垃圾收集器，全局标记-整理算法，局部采用复制算法。
      - 特点：
        - 适用于大内存场景，兼顾了吞吐量和低延迟，且可预测停顿，能够设置 GC 时间，但是需要设置在合理的阈值，不然可能导致部分对象无法回收。
        - 其改变了之前物理上的新老年代的划分，以 Region 划分内存，逻辑上分为 eden、survivor、old 和存储巨型对象的 Humongous 区。
    - ZGC：
      - 采用标记- 整理算法的全功能并行垃圾收集器。
      - 特点：兼顾了极低的延迟和及其广泛的内存适用区间，JDK 11 以后才支持。